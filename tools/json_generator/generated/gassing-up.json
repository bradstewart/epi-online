{"problem": "In the gasup problem, a number of cities are arranged on a circular road. You need to visit all the cities and come back to the starting city. A certain amount of gas is available at each city. The amount of gas summed up over all cities is equal to the amount of gas required to go around the road once. Your gas tank has unlimited capacity. Call a city ample if you can begin at that city with an empty tank, refill at it, then travel through all remaining cities, refilling at each, and return to the ample city, without running out of gas at any point. See the figure for an example. <p> <img src=\"http://raw.githubusercontent.com/bradstewart/epi-online/master/static/posts/gassing-up.png\"/> <p> Write a program, that takes an array of gallons available at each city and distances between cities and returns an id of an ample city.", "code": {"cpp": {"harness": "#include \"test_toolkit/test-options.h\"\n// Copyright (c) 2015 Elements of Programming Interviews. All rights reserved.\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <random>\n#include <utility>\n#include <vector>\n\n#include \"test_toolkit/main_def.h\"\n\nusing std::cout;\nusing std::default_random_engine;\nusing std::endl;\nusing std::random_device;\nusing std::uniform_int_distribution;\nusing std::vector;\n\nconst int kMPG = 20;\n// gallons[i] is the amount of gas in city i, and distances[i] is the distance\n// city i to the next city.\n//INSERT_ME\n\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const vector<int>& gallons, vector<int> distances_measured_in_gallons,\n              size_t expected) {\n  for (auto& x : distances_measured_in_gallons) //Convert distance to miles\n    x *= kMPG;\n\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->GetInputWriter()->\n      WritePair(\"MPG\", kMPG).\n      WritePair(\"Distances\", distances_measured_in_gallons).\n      WritePair(\"Gallons\", gallons);\n  stream->RegisterExpectedOutput(expected);\n  try {\n    size_t result = FindAmpleCity(gallons, distances_measured_in_gallons);\n    stream->RegisterUserOutput(result, result == expected);\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\n\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(12, \"Gassing up\");\n\n  UnitTest(sentry, \"Trivial test\", {0}, {0}, 0);\n  UnitTest(sentry, \"Small test\", {7, 2, 20}, {13, 5, 7}, 2);\n  UnitTest(sentry, \"Medium test\",\n           {0, 18, 13, 16, 7, 8, 4, 17}, {2, 28, 1, 15, 4, 18, 8, 7}, 2);\n  UnitTest(sentry, \"Huge test\",\n           {20, 15, 15, 15, 35, 25, 30, 15, 65, 45, 10, 45, 25},\n           {15, 20, 50, 15, 15, 30, 20, 55, 20, 50, 10, 15, 15}, 8);\n  UnitTest(sentry, \"The largest amount of gas test\",\n           {200, 2, 2, 2, 10, 10}, {100, 40, 40, 40, 2, 2}, 4);\n  UnitTest(sentry, \"The shortest segment test\",\n           {30, 90, 30, 2, 10, 10}, {40, 30, 20, 40, 2, 40}, 1);\n}\n\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n", "skeleton": "size_t FindAmpleCity(const vector<int>& gallons,\n                     const vector<int>& distances) {\n  int remaining_gallons = 0;\n  struct CityAndRemainingGas {\n    int city = 0, remaining_gallons = 0;\n  };\n  CityAndRemainingGas city_remaining_gallons_pair;\n  const int num_cities = gallons.size();\n  for (int i = 1; i < num_cities; ++i) {\n    remaining_gallons += gallons[i - 1] - distances[i - 1] / kMPG;\n    if (remaining_gallons < city_remaining_gallons_pair.remaining_gallons) {\n      city_remaining_gallons_pair = {i, remaining_gallons};\n    }\n  }\n  return city_remaining_gallons_pair.city;\n}\n", "header": "const int kMPG = 20;\n", "filename": "Gassing_upTest.cc"}}, "hint": "Think about starting with more than enough gas to complete the circuit without gassing up. Track the amount of gas as you perform the circuit, gassing up at each cities.", "slug": "gassing-up", "title": "The gasup problem"}