{"problem": "Sudoku is a popular logic-based combinatorial number placement puzzle. The objective is to fill a 9 x 9 grid with digits subject to the constraint that each column, each row, and each of the nine 3 x 3 sub-grids that compose the grid contains unique integers in [1, 9]. The grid is initialized with a partial assignment as shown in the following figure <p> <img src=\"http://raw.githubusercontent.com/bradstewart/epi-online/master/static/posts/sudoku-1.png\"/> <p> A complete solution is shown here <p> <img src=\"http://raw.githubusercontent.com/bradstewart/epi-online/master/static/posts/sudoku-2.png\"/> <p>Implement a Sudoku solver. The program takes 2D grid of integers, where zero means an undefined cell and numbers greater than zero represents cells with known value. The task is to eliminate all zeros in respect of mentioned constraints.", "hint": "Apply the constraints to speed-up a brute-force algorithm.", "title": "Implement a Sudoku solver", "code": {"cpp": {"skeleton": "bool SolveSudoku(vector<vector<int>>* partial_assignment) {\n  return SolvePartialSudoku(0, 0, partial_assignment);\n}\n", "header": "const int kEmptyEntry = 0;\n", "filename": "Sudoku_solveTest.cc", "harness": "#include \"test_toolkit/test-options.h\"\n// Copyright (c) 2013 Elements of Programming Interviews. All rights reserved.\n\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\n#include \"test_toolkit/main_def.h\"\n\nusing std::cout;\nusing std::deque;\nusing std::endl;\nusing std::ostream_iterator;\nusing std::vector;\n\ntypedef vector<vector<int>> SudokuField; //FIXME(Kroilov) Include this typedef into book listing?\nbool SolvePartialSudoku(int, int, vector<vector<int>>*);\nbool ValidToAddVal(const vector<vector<int>>&, int, int, int);\nconst int kEmptyEntry = 0;\n//INSERT_ME\nbool SolvePartialSudoku(int i, int j,\n                        vector<vector<int>>* partial_assignment) {\n  if (i == partial_assignment->size()) {\n    i = 0;  // Starts a new row.\n    if (++j == (*partial_assignment)[i].size()) {\n      return true;  // Entire matrix has been filled without conflict.\n    }\n  }\n\n  // Skips nonempty entries.\n  if ((*partial_assignment)[i][j] != kEmptyEntry) {\n    return SolvePartialSudoku(i + 1, j, partial_assignment);\n  }\n\n  for (int val = 1; val <= partial_assignment->size(); ++val) {\n    // It's substantially quicker to check if entry val conflicts\n    // with any of the constraints if we add it at (i,j) before\n    // adding it, rather than adding it and then checking all constraints.\n    // The reason is that we know we are starting with a valid configuration,\n    // and the only entry which can cause a problem is entryval at (i,j).\n    if (ValidToAddVal(*partial_assignment, i, j, val)) {\n      (*partial_assignment)[i][j] = val;\n      if (SolvePartialSudoku(i + 1, j, partial_assignment)) {\n        return true;\n      }\n    }\n  }\n\n  (*partial_assignment)[i][j] = kEmptyEntry;  // Undo assignment.\n  return false;\n}\n\nbool ValidToAddVal(const vector<vector<int>>& partial_assignment, int i,\n                   int j, int val) {\n  // Check row constraints.\n  for (int k = 0; k < partial_assignment.size(); ++k) {\n    if (val == partial_assignment[k][j]) {\n      return false;\n    }\n  }\n\n  // Check column constraints.\n  if (any_of(begin(partial_assignment[i]), end(partial_assignment[i]),\n             [val](int a) { return val == a; })) {\n    return false;\n  }\n\n  // Check region constraints.\n  int region_size = sqrt(partial_assignment.size());\n  int I = i / region_size, J = j / region_size;\n  for (int a = 0; a < region_size; ++a) {\n    for (int b = 0; b < region_size; ++b) {\n      if (val ==\n          partial_assignment[region_size * I + a][region_size * J + b]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n// Copyright (c) 2015 Elements of Programming Interviews. All rights reserved.\n\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <vector>\n\n#include \"test_toolkit/main_def.h\"\n\nusing std::deque;\nusing std::vector;\n\nbool HasDuplicate(const vector<vector<int>>&, int, int, int, int);\n\n// Check if a partially filled matrix has any conflicts.\nbool IsValidSudoku(const vector<vector<int>>& partial_assignment) {\n  // Check row constraints.\n  for (int i = 0; i < partial_assignment.size(); ++i) {\n    if (HasDuplicate(partial_assignment, i, i + 1, 0,\n                     partial_assignment.size())) {\n      return false;\n    }\n  }\n\n  // Check column constraints.\n  for (int j = 0; j < partial_assignment.size(); ++j) {\n    if (HasDuplicate(partial_assignment, 0, partial_assignment.size(), j,\n                     j + 1)) {\n      return false;\n    }\n  }\n\n  // Check region constraints.\n  int region_size = sqrt(partial_assignment.size());\n  for (int I = 0; I < region_size; ++I) {\n    for (int J = 0; J < region_size; ++J) {\n      if (HasDuplicate(partial_assignment, region_size * I,\n                       region_size * (I + 1), region_size * J,\n                       region_size * (J + 1))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// Return true if subarray partial_assignment[start_row : end_row -\n// 1][start_col : end_col - 1] contains any duplicates in {1, 2, ...,\n// partial_assignment.size()}; otherwise return false.\nbool HasDuplicate(const vector<vector<int>>& partial_assignment,\n                  int start_row, int end_row, int start_col, int end_col) {\n  deque<bool> is_present(partial_assignment.size() + 1, false);\n  for (int i = start_row; i < end_row; ++i) {\n    for (int j = start_col; j < end_col; ++j) {\n      if (partial_assignment[i][j] != 0 &&\n          is_present[partial_assignment[i][j]]) {\n        return true;\n      }\n      is_present[partial_assignment[i][j]] = true;\n    }\n  }\n  return false;\n}\n\nint MAIN_FUNC(int argc, char* argv[]) {\n  vector<vector<int>> A(9, vector<int>(9, 0));\n  A[0] = {0, 2, 6, 0, 0, 0, 8, 1, 0};\n  A[1] = {3, 0, 0, 7, 0, 8, 0, 0, 6};\n  A[2] = {4, 0, 0, 0, 5, 0, 0, 0, 7};\n  A[3] = {0, 5, 0, 1, 0, 7, 0, 9, 0};\n  A[4] = {0, 0, 3, 9, 0, 5, 1, 0, 0};\n  A[5] = {0, 4, 0, 3, 0, 2, 0, 5, 0};\n  A[6] = {1, 0, 0, 0, 3, 0, 0, 0, 2};\n  A[7] = {5, 0, 0, 2, 0, 4, 0, 0, 9};\n  A[8] = {0, 3, 8, 0, 0, 0, 4, 6, 0};\n  assert(IsValidSudoku(A));\n  // There are two 3s.\n  A[8] = {3, 3, 8, 0, 0, 0, 4, 6, 0};\n  assert(!IsValidSudoku(A));\n  return 0;\n}\n\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              SudokuField input) {\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->RegisterInput(input);\n  stream->RegisterExpectedOutput(\"\");\n  try {\n    SolveSudoku(&input);\n    stream->RegisterUserOutput(input, IsValidSudoku(input));\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\n\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(16, \"Sudoku solver\");\n\n  UnitTest(sentry, \"Trivial test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 1, 4, 7, 6, 9, 3},\n            {6, 7, 3, 9, 8, 5, 1, 2, 4},\n            {9, 4, 1, 3, 6, 2, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Single missing element test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 1, 0, 7, 6, 9, 3},\n            {6, 7, 3, 9, 8, 5, 1, 2, 4},\n            {9, 4, 1, 3, 6, 2, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Single missing block test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 0, 0, 0, 6, 9, 3},\n            {6, 7, 3, 0, 0, 0, 1, 2, 4},\n            {9, 4, 1, 0, 0, 0, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Easy sudoku test\",\n           {{4, 0, 8, 6, 1, 9, 5, 7, 2},\n            {2, 7, 0, 3, 5, 0, 6, 4, 1},\n            {1, 6, 0, 4, 2, 7, 9, 3, 8},\n            {8, 5, 1, 7, 6, 0, 3, 9, 4},\n            {6, 0, 3, 1, 9, 5, 8, 2, 7},\n            {9, 2, 7, 8, 3, 4, 1, 5, 6},\n            {3, 8, 0, 9, 4, 1, 7, 6, 5},\n            {0, 9, 4, 0, 8, 6, 2, 1, 3},\n            {0, 1, 6, 2, 7, 3, 4, 0, 9}});\n  UnitTest(sentry, \"Medium sudoku test\",\n           {{0, 0, 0, 1, 7, 4, 0, 8, 3},\n            {4, 7, 0, 6, 8, 3, 0, 0, 0},\n            {3, 8, 0, 2, 9, 5, 7, 0, 0},\n            {0, 0, 4, 9, 5, 1, 0, 7, 6},\n            {1, 0, 5, 0, 2, 0, 0, 4, 0},\n            {0, 9, 7, 4, 6, 8, 1, 3, 0},\n            {7, 0, 0, 0, 0, 9, 8, 6, 0},\n            {6, 0, 0, 7, 4, 0, 3, 5, 0},\n            {0, 0, 3, 8, 0, 6, 0, 0, 0}});\n  UnitTest(sentry, \"Hard sudoku test\",\n           {{0, 2, 6, 0, 0, 0, 8, 1, 0},\n            {3, 0, 0, 7, 0, 8, 0, 0, 6},\n            {4, 0, 0, 0, 5, 0, 0, 0, 7},\n            {0, 5, 0, 1, 0, 7, 0, 9, 0},\n            {0, 0, 3, 9, 0, 5, 1, 0, 0},\n            {0, 4, 0, 3, 0, 2, 0, 5, 0},\n            {1, 0, 0, 0, 3, 0, 0, 0, 2},\n            {5, 0, 0, 2, 0, 4, 0, 0, 9},\n            {0, 3, 8, 0, 0, 0, 4, 6, 0}});\n}\n\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n"}}, "slug": "sudoku-solve"}