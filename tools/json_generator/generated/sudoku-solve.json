{"code": {"cpp": {"filename": "Sudoku_solveTest.cc", "harness": "#include \"test_toolkit/test-options.h\"\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <iostream>\n#include <iterator>\n#include <vector>\n#include \"test_toolkit/main_def.h\"\nusing std::cout;\nusing std::deque;\nusing std::endl;\nusing std::ostream_iterator;\nusing std::vector;\ntypedef vector<vector<int>> SudokuField; //FIXME(Kroilov) Include this typedef into book listing?\nconst int kEmptyEntry = 0;\n//INSERT_ME\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <vector>\n#include \"test_toolkit/main_def.h\"\nusing std::deque;\nusing std::vector;\nbool HasDuplicate(const vector<vector<int>>&, int, int, int, int);\nbool IsValidSudoku(const vector<vector<int>>& partial_assignment) {\n  for (int i = 0; i < partial_assignment.size(); ++i) {\n    if (HasDuplicate(partial_assignment, i, i + 1, 0,\n                     partial_assignment.size())) {\n      return false;\n    }\n  }\n  for (int j = 0; j < partial_assignment.size(); ++j) {\n    if (HasDuplicate(partial_assignment, 0, partial_assignment.size(), j,\n                     j + 1)) {\n      return false;\n    }\n  }\n  int region_size = sqrt(partial_assignment.size());\n  for (int I = 0; I < region_size; ++I) {\n    for (int J = 0; J < region_size; ++J) {\n      if (HasDuplicate(partial_assignment, region_size * I,\n                       region_size * (I + 1), region_size * J,\n                       region_size * (J + 1))) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nbool HasDuplicate(const vector<vector<int>>& partial_assignment,\n                  int start_row, int end_row, int start_col, int end_col) {\n  deque<bool> is_present(partial_assignment.size() + 1, false);\n  for (int i = start_row; i < end_row; ++i) {\n    for (int j = start_col; j < end_col; ++j) {\n      if (partial_assignment[i][j] != 0 &&\n          is_present[partial_assignment[i][j]]) {\n        return true;\n      }\n      is_present[partial_assignment[i][j]] = true;\n    }\n  }\n  return false;\n}\nint MAIN_FUNC(int argc, char* argv[]) {\n  vector<vector<int>> A(9, vector<int>(9, 0));\n  A[0] = {0, 2, 6, 0, 0, 0, 8, 1, 0};\n  A[1] = {3, 0, 0, 7, 0, 8, 0, 0, 6};\n  A[2] = {4, 0, 0, 0, 5, 0, 0, 0, 7};\n  A[3] = {0, 5, 0, 1, 0, 7, 0, 9, 0};\n  A[4] = {0, 0, 3, 9, 0, 5, 1, 0, 0};\n  A[5] = {0, 4, 0, 3, 0, 2, 0, 5, 0};\n  A[6] = {1, 0, 0, 0, 3, 0, 0, 0, 2};\n  A[7] = {5, 0, 0, 2, 0, 4, 0, 0, 9};\n  A[8] = {0, 3, 8, 0, 0, 0, 4, 6, 0};\n  assert(IsValidSudoku(A));\n  A[8] = {3, 3, 8, 0, 0, 0, 4, 6, 0};\n  assert(!IsValidSudoku(A));\n  return 0;\n}\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              SudokuField input) {\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->RegisterInput(input);\n  stream->RegisterExpectedOutput(\"\");\n  try {\n    SolveSudoku(&input);\n    stream->RegisterUserOutput(input, IsValidSudoku(input));\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(16, \"Sudoku solver\");\n  UnitTest(sentry, \"Trivial test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 1, 4, 7, 6, 9, 3},\n            {6, 7, 3, 9, 8, 5, 1, 2, 4},\n            {9, 4, 1, 3, 6, 2, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Single missing element test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 1, 0, 7, 6, 9, 3},\n            {6, 7, 3, 9, 8, 5, 1, 2, 4},\n            {9, 4, 1, 3, 6, 2, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Single missing block test\",\n           {{7, 2, 6, 4, 9, 3, 8, 1, 5},\n            {3, 1, 5, 7, 2, 8, 9, 4, 6},\n            {4, 8, 9, 6, 5, 1, 2, 3, 7},\n            {8, 5, 2, 0, 0, 0, 6, 9, 3},\n            {6, 7, 3, 0, 0, 0, 1, 2, 4},\n            {9, 4, 1, 0, 0, 0, 7, 5, 8},\n            {1, 9, 4, 8, 3, 6, 5, 7, 2},\n            {5, 6, 7, 2, 1, 4, 3, 8, 9},\n            {2, 3, 8, 5, 7, 9, 4, 6, 1}});\n  UnitTest(sentry, \"Easy sudoku test\",\n           {{4, 0, 8, 6, 1, 9, 5, 7, 2},\n            {2, 7, 0, 3, 5, 0, 6, 4, 1},\n            {1, 6, 0, 4, 2, 7, 9, 3, 8},\n            {8, 5, 1, 7, 6, 0, 3, 9, 4},\n            {6, 0, 3, 1, 9, 5, 8, 2, 7},\n            {9, 2, 7, 8, 3, 4, 1, 5, 6},\n            {3, 8, 0, 9, 4, 1, 7, 6, 5},\n            {0, 9, 4, 0, 8, 6, 2, 1, 3},\n            {0, 1, 6, 2, 7, 3, 4, 0, 9}});\n  UnitTest(sentry, \"Medium sudoku test\",\n           {{0, 0, 0, 1, 7, 4, 0, 8, 3},\n            {4, 7, 0, 6, 8, 3, 0, 0, 0},\n            {3, 8, 0, 2, 9, 5, 7, 0, 0},\n            {0, 0, 4, 9, 5, 1, 0, 7, 6},\n            {1, 0, 5, 0, 2, 0, 0, 4, 0},\n            {0, 9, 7, 4, 6, 8, 1, 3, 0},\n            {7, 0, 0, 0, 0, 9, 8, 6, 0},\n            {6, 0, 0, 7, 4, 0, 3, 5, 0},\n            {0, 0, 3, 8, 0, 6, 0, 0, 0}});\n  UnitTest(sentry, \"Hard sudoku test\",\n           {{0, 2, 6, 0, 0, 0, 8, 1, 0},\n            {3, 0, 0, 7, 0, 8, 0, 0, 6},\n            {4, 0, 0, 0, 5, 0, 0, 0, 7},\n            {0, 5, 0, 1, 0, 7, 0, 9, 0},\n            {0, 0, 3, 9, 0, 5, 1, 0, 0},\n            {0, 4, 0, 3, 0, 2, 0, 5, 0},\n            {1, 0, 0, 0, 3, 0, 0, 0, 2},\n            {5, 0, 0, 2, 0, 4, 0, 0, 9},\n            {0, 3, 8, 0, 0, 0, 4, 6, 0}});\n}\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n", "header": "const int kEmptyEntry = 0;\n", "skeleton": "bool SolveSudoku(vector<vector<int>>* partial_assignment) {\n    // Your solution here...\n}\n"}, "java": {"filename": "SudokuSolveTest.java", "harness": "public class SudokuSolveTest {\n  private static final int EMPTY_ENTRY = 0;\n//INSERT_ME\n  public static boolean isValidSudoku(List<List<Integer>> partialAssignment) {\n    for (int i = 0; i < partialAssignment.size(); ++i) {\n      if (hasDuplicate(partialAssignment, i, i + 1, 0,\n                       partialAssignment.size())) {\n        return false;\n      }\n    }\n    for (int j = 0; j < partialAssignment.size(); ++j) {\n      if (hasDuplicate(partialAssignment, 0, partialAssignment.size(), j,\n                       j + 1)) {\n        return false;\n      }\n    }\n    int regionSize = (int)Math.sqrt(partialAssignment.size());\n    for (int I = 0; I < regionSize; ++I) {\n      for (int J = 0; J < regionSize; ++J) {\n        if (hasDuplicate(partialAssignment, regionSize * I,\n                         regionSize * (I + 1), regionSize * J,\n                         regionSize * (J + 1))) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  private static boolean hasDuplicate(List<List<Integer>> partialAssignment,\n                                      int startRow, int endRow, int startCol,\n                                      int endCol) {\n    List<Boolean> isPresent = new ArrayList<>(\n        Collections.nCopies(partialAssignment.size() + 1, false));\n    for (int i = startRow; i < endRow; ++i) {\n      for (int j = startCol; j < endCol; ++j) {\n        if (partialAssignment.get(i).get(j) != 0\n            && isPresent.get(partialAssignment.get(i).get(j))) {\n          return true;\n        }\n        isPresent.set(partialAssignment.get(i).get(j), true);\n      }\n    }\n    return false;\n  }\n  private static void unitTest(AbstractTestOptions options, String description,\n                               List<List<Integer>> input) {\n    AbstractTestStream stream = options.getStream();\n    stream.startTest(TestType.NORMAL, description);\n    stream.registerInput(input);\n    stream.registerExpectedOutput(null);\n    try {\n      solveSudoku(input);\n      stream.registerUserOutput(input, isValidSudoku(input));\n    }\n    catch (NullPointerException e) {\n      stream.registerNullPointerException();\n    }\n    catch (Exception e) {\n      stream.registerUnhandledException();\n    }\n    stream.endTest();\n  }\n  public static void directedTests(AbstractTestOptions options) {\n    options.startTests(0, \"Sudoku solver\");\n    unitTest(options, \"Trivial test\",\n        Arrays.asList(\n            Arrays.asList(7, 2, 6, 4, 9, 3, 8, 1, 5),\n            Arrays.asList(3, 1, 5, 7, 2, 8, 9, 4, 6),\n            Arrays.asList(4, 8, 9, 6, 5, 1, 2, 3, 7),\n            Arrays.asList(8, 5, 2, 1, 4, 7, 6, 9, 3),\n            Arrays.asList(6, 7, 3, 9, 8, 5, 1, 2, 4),\n            Arrays.asList(9, 4, 1, 3, 6, 2, 7, 5, 8),\n            Arrays.asList(1, 9, 4, 8, 3, 6, 5, 7, 2),\n            Arrays.asList(5, 6, 7, 2, 1, 4, 3, 8, 9),\n            Arrays.asList(2, 3, 8, 5, 7, 9, 4, 6, 1)));\n    unitTest(options, \"Single missing element test\",\n        Arrays.asList(\n            Arrays.asList(7, 2, 6, 4, 9, 3, 8, 1, 5),\n            Arrays.asList(3, 1, 5, 7, 2, 8, 9, 4, 6),\n            Arrays.asList(4, 8, 9, 6, 5, 1, 2, 3, 7),\n            Arrays.asList(8, 5, 2, 1, 0, 7, 6, 9, 3),\n            Arrays.asList(6, 7, 3, 9, 8, 5, 1, 2, 4),\n            Arrays.asList(9, 4, 1, 3, 6, 2, 7, 5, 8),\n            Arrays.asList(1, 9, 4, 8, 3, 6, 5, 7, 2),\n            Arrays.asList(5, 6, 7, 2, 1, 4, 3, 8, 9),\n            Arrays.asList(2, 3, 8, 5, 7, 9, 4, 6, 1)));\n    unitTest(options, \"Single missing block test\",\n        Arrays.asList(\n            Arrays.asList(7, 2, 6, 4, 9, 3, 8, 1, 5),\n            Arrays.asList(3, 1, 5, 7, 2, 8, 9, 4, 6),\n            Arrays.asList(4, 8, 9, 6, 5, 1, 2, 3, 7),\n            Arrays.asList(8, 5, 2, 0, 0, 0, 6, 9, 3),\n            Arrays.asList(6, 7, 3, 0, 0, 0, 1, 2, 4),\n            Arrays.asList(9, 4, 1, 0, 0, 0, 7, 5, 8),\n            Arrays.asList(1, 9, 4, 8, 3, 6, 5, 7, 2),\n            Arrays.asList(5, 6, 7, 2, 1, 4, 3, 8, 9),\n            Arrays.asList(2, 3, 8, 5, 7, 9, 4, 6, 1)));\n    unitTest(options, \"Easy sudoku test\",\n        Arrays.asList(\n            Arrays.asList(4, 0, 8, 6, 1, 9, 5, 7, 2),\n            Arrays.asList(2, 7, 0, 3, 5, 0, 6, 4, 1),\n            Arrays.asList(1, 6, 0, 4, 2, 7, 9, 3, 8),\n            Arrays.asList(8, 5, 1, 7, 6, 0, 3, 9, 4),\n            Arrays.asList(6, 0, 3, 1, 9, 5, 8, 2, 7),\n            Arrays.asList(9, 2, 7, 8, 3, 4, 1, 5, 6),\n            Arrays.asList(3, 8, 0, 9, 4, 1, 7, 6, 5),\n            Arrays.asList(0, 9, 4, 0, 8, 6, 2, 1, 3),\n            Arrays.asList(0, 1, 6, 2, 7, 3, 4, 0, 9)));\n    unitTest(options, \"Medium sudoku test\",\n        Arrays.asList(\n            Arrays.asList(0, 0, 0, 1, 7, 4, 0, 8, 3),\n            Arrays.asList(4, 7, 0, 6, 8, 3, 0, 0, 0),\n            Arrays.asList(3, 8, 0, 2, 9, 5, 7, 0, 0),\n            Arrays.asList(0, 0, 4, 9, 5, 1, 0, 7, 6),\n            Arrays.asList(1, 0, 5, 0, 2, 0, 0, 4, 0),\n            Arrays.asList(0, 9, 7, 4, 6, 8, 1, 3, 0),\n            Arrays.asList(7, 0, 0, 0, 0, 9, 8, 6, 0),\n            Arrays.asList(6, 0, 0, 7, 4, 0, 3, 5, 0),\n            Arrays.asList(0, 0, 3, 8, 0, 6, 0, 0, 0)));\n    unitTest(options, \"Hard sudoku test\",\n        Arrays.asList(\n            Arrays.asList(0, 2, 6, 0, 0, 0, 8, 1, 0),\n            Arrays.asList(3, 0, 0, 7, 0, 8, 0, 0, 6),\n            Arrays.asList(4, 0, 0, 0, 5, 0, 0, 0, 7),\n            Arrays.asList(0, 5, 0, 1, 0, 7, 0, 9, 0),\n            Arrays.asList(0, 0, 3, 9, 0, 5, 1, 0, 0),\n            Arrays.asList(0, 4, 0, 3, 0, 2, 0, 5, 0),\n            Arrays.asList(1, 0, 0, 0, 3, 0, 0, 0, 2),\n            Arrays.asList(5, 0, 0, 2, 0, 4, 0, 0, 9),\n            Arrays.asList(0, 3, 8, 0, 0, 0, 4, 6, 0)));\n    options.endTests();\n  }\n  public static void main(String[] args) {\n    directedTests(new JsonTestOptions(System.out));\n  }\n}\n", "header": "  private static final int EMPTY_ENTRY = 0;\n", "imports": "import com.epi.utils.AbstractTestOptions;\nimport com.epi.utils.AbstractTestStream;\nimport com.epi.utils.JsonTestOptions;\nimport com.epi.utils.TestType;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n", "package": "package com.epi;\n", "skeleton": "  public static boolean solveSudoku(List<List<Integer>> partialAssignment) {\n    // Your solution here...\n  }\n"}}, "hint": "Apply the constraints to speed-up a brute-force algorithm.", "problem": "Sudoku is a popular logic-based combinatorial number placement puzzle. The objective is to fill a 9 x 9 grid with digits subject to the constraint that each column, each row, and each of the nine 3 x 3 sub-grids that compose the grid contains unique integers in [1, 9]. The grid is initialized with a partial assignment as shown in the following figure <p> <img src=\"http://raw.githubusercontent.com/bradstewart/epi-online/master/static/posts/sudoku-1.png\"/> <p> A complete solution is shown here <p> <img src=\"http://raw.githubusercontent.com/bradstewart/epi-online/master/static/posts/sudoku-2.png\"/> <p>Implement a Sudoku solver. The program takes 2D grid of integers, where zero means an undefined cell and numbers greater than zero represents cells with known value. The task is to eliminate all zeros in respect of mentioned constraints.", "slug": "sudoku-solve", "title": "Implement a Sudoku solver"}