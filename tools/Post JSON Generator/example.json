{"title": "Test if a binary tree is balanced.", "slug": "is-binary-tree-balanced", "hint": "Think of a classic binary tree algorithm.", "cpp": {"harness": "#include <limits> \n\n#include \"test_toolkit/test-options.h\"\n#include \"test_toolkit/tree_utils.h\"\n\n// Copyright (c) 2015 Elements of Programming Interviews. All rights reserved.\n\n#ifndef SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n#define SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n\n#include <memory>\n\n#include \"test_toolkit/more_type_traits.h\"\n\nusing std::unique_ptr;\n\n// @include\ntemplate <typename T>\nstruct BinaryTreeNode {\n  T data;\n  unique_ptr<BinaryTreeNode<T>> left, right;\n};\n// @exclude\n\nREGISTER_TREE_TYPE(unique_ptr<BinaryTreeNode<T>>)\n\n#endif  // SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n// Copyright (c) 2015 Elements of Programming Interviews. All rights reserved.\n\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <utility>\n\n#include \"./Binary_tree_prototype.h\"\n#include \"test_toolkit/main_def.h\"\n\nusing std::boolalpha;\nusing std::cout;\nusing std::endl;\nusing std::make_unique;\nusing std::max;\nusing std::pair;\nusing std::tie;\nusing std::unique_ptr;\n\nstruct BalancedStatusWithHeight;\nBalancedStatusWithHeight CheckBalanced(\n    const unique_ptr<BinaryTreeNode<int>>&);\n\n// @include\nstruct BalancedStatusWithHeight {\n  bool balanced;\n  int height;\n};\n\nusing std::numeric_limits;\n\nusing Node = BinaryTreeNode<int>;\nusing NodePtr = unique_ptr<Node>;\n\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const NodePtr& tree, bool expected) {\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->RegisterInput(tree);\n  stream->RegisterExpectedOutput(expected);\n  try {\n    bool result = IsBalanced(tree);\n    stream->RegisterUserOutput(result, result == expected);\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\n\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const vector<int>& tree, bool expected) {\n  UnitTest(sentry, description, BuildTree(tree), expected);\n}\n\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(0, \"Check if binary tree is height-balanced\");\n\n  UnitTest(sentry, \"Trivial test\", NodePtr(), true);\n  UnitTest(sentry, \"Positive test #1\", {1}, true);\n  UnitTest(sentry, \"Positive test #2\", {1, 2}, true);\n  UnitTest(sentry, \"Positive test #3\", {2, 1}, true);\n  UnitTest(sentry, \"Positive test #4\", {2, 1, 3}, true);\n  UnitTest(sentry, \"Positive test #5\", {5, 3, 1, 4, 7, 6, 8}, true);\n  UnitTest(sentry, \"Positive test #6\", {5, 3, numeric_limits<int>::min(), 4, numeric_limits<int>::max()}, true);\n  UnitTest(sentry, \"Negative test #1\", {5, 3, 2}, false);\n  UnitTest(sentry, \"Negative test #2\", {5, 3, 4}, false);\n  UnitTest(sentry, \"Negative test #3\", {5, 7, 6}, false);\n  UnitTest(sentry, \"Negative test #4\", {5, 7, 8}, false);\n  UnitTest(sentry, \"Negative test #5\", {5, 4, 3, 2, 7, 6, 8, 9}, false);\n\n  NodePtr a(new Node());\n  NodePtr b(new Node());\n  NodePtr c(new Node());\n  NodePtr d(new Node());\n  NodePtr e(new Node());\n  NodePtr f(new Node());\n  NodePtr g(new Node());\n  NodePtr h(new Node());\n  NodePtr i(new Node());\n  NodePtr j(new Node());\n  NodePtr k(new Node());\n  NodePtr l(new Node());\n  NodePtr m(new Node());\n  NodePtr n(new Node());\n  NodePtr o(new Node());\n\n  a->data = 1;\n  b->data = 0;\n  c->data = 1;\n  d->data = 0;\n  e->data = 1;\n  f->data = 0;\n  g->data = 1;\n  h->data = 0;\n  i->data = 1;\n  j->data = 0;\n  k->data = 1;\n  l->data = 0;\n  m->data = 1;\n  n->data = 0;\n  o->data = 1;\n\n  l->right = move(n);\n  l->left  = move(m);\n  k->right = move(o);\n  k->left  = move(l);\n  h->right = move(j);\n  h->left  = move(i);\n  d->right = move(f);\n  d->left  = move(e);\n  c->right = move(g);\n  c->left  = move(d);\n  b->right = move(h);\n  b->left  = move(c);\n  a->right = move(k);\n  a->left  = move(b);\n\n  UnitTest(sentry, \"Example from the book test\", a, true);\n}\n\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n\n", "header": "using std::unique_ptr;\n\n// @include\ntemplate <typename T>\nstruct BinaryTreeNode {\n  T data;\n  unique_ptr<BinaryTreeNode<T>> left, right;\n};\n// @exclude\n// @include\nstruct BalancedStatusWithHeight {\n  bool balanced;\n  int height;\n};\n", "skeleton": "bool IsBalanced(const unique_ptr<BinaryTreeNode<int>>& tree) {\n//INSERT_ME\n}\n"}, "problem": "A binary tree is said to be balanced if for each node in the tree,\r\n   the difference in the height of its left and right subtrees is at most one.\r\n   A perfect binary tree is balanced, as is a complete binary tree.\r\n   A balanced binary tree does not have to be perfect or complete---see the\r\n   figure for an example.\r\n   <p>\r\n   Write a program that takes as input the root of a binary tree\r\n   and checks whether the tree is balanced.\r\n   <p>\r\n   The binary tree class is\r\n<pre>\r\n   class BinaryTreeNode<T> {\r\n       public T data;\r\n       public BinaryTreeNode<T> left, right;\r\n   }\r\n   public BinaryTreeNode(T data) { this.data = data; }\r\n   public BinaryTreeNode(T data, BinaryTreeNode<T> left,\r\n                          BinaryTreeNode<T> right) {\r\n     this.data = data;\r\n     this.left = left;\r\n     this.right = right;\r\n   }\r\n</pre>\r\n<p>\r\n   <img src=\"/static/posts/binary-tree.png\"></img>"}