{
  "slug": "is-binary-tree-balanced",
  "title": "Test if a binary tree is balanced.",
  "hint": "Think of a classic binary tree algorithm.",
  "problem": "A binary tree is said to be balanced if for each node in the tree,\r\n   the difference in the height of its left and right subtrees is at most one.\r\n   A perfect binary tree is balanced, as is a complete binary tree.\r\n   A balanced binary tree does not have to be perfect or complete---see the\r\n   figure for an example.\r\n   <p>\r\n   Write a program that takes as input the root of a binary tree\r\n   and checks whether the tree is balanced.\r\n   <p>\r\n   The binary tree class is\r\n<pre>\r\n   class BinaryTreeNode<T> {\r\n       public T data;\r\n       public BinaryTreeNode<T> left, right;\r\n   }\r\n   public BinaryTreeNode(T data) { this.data = data; }\r\n   public BinaryTreeNode(T data, BinaryTreeNode<T> left,\r\n                          BinaryTreeNode<T> right) {\r\n     this.data = data;\r\n     this.left = left;\r\n     this.right = right;\r\n   }\r\n<\/pre>\r\n<p>\r\n   <img src=\"\/static/posts/binary-tree.png\"><\/img>",
  "skeleton": "public static boolean isBalanced(BinaryTreeNode<Integer> tree) {\r\n    \/\/ Your solution here...\r\n}",
  "test": "private static BalanceStatusWithHeight checkBalanced(\r\n      BinaryTreeNode<Integer> tree) {\r\n    if (tree == null) {\r\n      return new BalanceStatusWithHeight(true, -1); \/\/ Base case.\r\n    }\r\n\r\n    BalanceStatusWithHeight leftResult = checkBalanced(tree.left);\r\n    if (!leftResult.balanced) {\r\n      return leftResult; \/\/ Left subtree is not balanced.\r\n    }\r\n    BalanceStatusWithHeight rightResult = checkBalanced(tree.right);\r\n    if (!rightResult.balanced) {\r\n      return rightResult; \/\/ Right subtree is not balanced.\r\n    }\r\n\r\n    boolean isBalanced = Math.abs(leftResult.height - rightResult.height) <= 1;\r\n    int height = Math.max(leftResult.height, rightResult.height) + 1;\r\n    return new BalanceStatusWithHeight(isBalanced, height);\r\n  }"
}
