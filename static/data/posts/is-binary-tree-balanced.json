{"code": {"cpp": {"filename": "Balanced_binary_treeTest.cc", "harness": "#include <limits>\n#include \"test_toolkit/test-options.h\"\n#include \"test_toolkit/tree_utils.h\"\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <memory>\n#include <utility>\n#ifndef SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n#define SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n#include <memory>\n#include \"test_toolkit/more_type_traits.h\"\nusing std::unique_ptr;\ntemplate <typename T>\nstruct BinaryTreeNode {\n  T data;\n  unique_ptr<BinaryTreeNode<T>> left, right;\n};\nREGISTER_TREE_TYPE(unique_ptr<BinaryTreeNode<T>>)\n#endif  // SOLUTIONS_BINARY_TREE_PROTOTYPE_H_\n#include \"test_toolkit/main_def.h\"\nusing std::boolalpha;\nusing std::cout;\nusing std::endl;\nusing std::make_unique;\nusing std::max;\nusing std::pair;\nusing std::tie;\nusing std::unique_ptr;\n//INSERT_ME\nusing std::numeric_limits;\nusing Node = BinaryTreeNode<int>;\nusing NodePtr = unique_ptr<Node>;\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const NodePtr& tree, bool expected) {\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->RegisterInput(tree);\n  stream->RegisterExpectedOutput(expected);\n  try {\n    bool result = IsBalanced(tree);\n    stream->RegisterUserOutput(result, result == expected);\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const vector<int>& tree, bool expected) {\n  UnitTest(sentry, description, BuildTree(tree), expected);\n}\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(0, \"Check if binary tree is height-balanced\");\n  UnitTest(sentry, \"Trivial test\", NodePtr(), true);\n  UnitTest(sentry, \"Positive test #1\", {1}, true);\n  UnitTest(sentry, \"Positive test #2\", {1, 2}, true);\n  UnitTest(sentry, \"Positive test #3\", {2, 1}, true);\n  UnitTest(sentry, \"Positive test #4\", {2, 1, 3}, true);\n  UnitTest(sentry, \"Positive test #5\", {5, 3, 1, 4, 7, 6, 8}, true);\n  UnitTest(sentry, \"Positive test #6\", {5, 3, numeric_limits<int>::min(), 4, numeric_limits<int>::max()}, true);\n  UnitTest(sentry, \"Negative test #1\", {5, 3, 2}, false);\n  UnitTest(sentry, \"Negative test #2\", {5, 3, 4}, false);\n  UnitTest(sentry, \"Negative test #3\", {5, 7, 6}, false);\n  UnitTest(sentry, \"Negative test #4\", {5, 7, 8}, false);\n  UnitTest(sentry, \"Negative test #5\", {5, 4, 3, 2, 7, 6, 8, 9}, false);\n  NodePtr a(new Node());\n  NodePtr b(new Node());\n  NodePtr c(new Node());\n  NodePtr d(new Node());\n  NodePtr e(new Node());\n  NodePtr f(new Node());\n  NodePtr g(new Node());\n  NodePtr h(new Node());\n  NodePtr i(new Node());\n  NodePtr j(new Node());\n  NodePtr k(new Node());\n  NodePtr l(new Node());\n  NodePtr m(new Node());\n  NodePtr n(new Node());\n  NodePtr o(new Node());\n  a->data = 1;\n  b->data = 0;\n  c->data = 1;\n  d->data = 0;\n  e->data = 1;\n  f->data = 0;\n  g->data = 1;\n  h->data = 0;\n  i->data = 1;\n  j->data = 0;\n  k->data = 1;\n  l->data = 0;\n  m->data = 1;\n  n->data = 0;\n  o->data = 1;\n  l->right = move(n);\n  l->left  = move(m);\n  k->right = move(o);\n  k->left  = move(l);\n  h->right = move(j);\n  h->left  = move(i);\n  d->right = move(f);\n  d->left  = move(e);\n  c->right = move(g);\n  c->left  = move(d);\n  b->right = move(h);\n  b->left  = move(c);\n  a->right = move(k);\n  a->left  = move(b);\n  UnitTest(sentry, \"Example from the book test\", a, true);\n}\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n", "header": "template <typename T>\nstruct BinaryTreeNode {\n  T data;\n  unique_ptr<BinaryTreeNode<T>> left, right;\n};\n", "skeleton": "bool IsBalanced(const unique_ptr<BinaryTreeNode<int>>& tree) {\n    // Your solution here...\n}\n"}, "java": {"filename": "BalancedBinaryTreeTest.java", "harness": "import com.epi.BinaryTreePrototypeTemplate.BinaryTreeNode;\npublic class BalancedBinaryTreeTest {\n//INSERT_ME\n  private static void unitTest(AbstractTestOptions options, String description,\n                               BinaryTreeNode<Integer> tree, boolean expected) {\n    AbstractTestStream stream = options.getStream();\n    stream.startTest(TestType.NORMAL, description);\n    stream.registerInput(tree);\n    stream.registerExpectedOutput(expected);\n    try {\n      boolean result = isBalanced(tree);\n      stream.registerUserOutput(result, expected == result);\n    } catch (NullPointerException e) {\n      stream.registerNullPointerException();\n    } catch (Exception e) {\n      stream.registerUnhandledException();\n    }\n    stream.endTest();\n  }\n  private static void unitTestHelper(AbstractTestOptions options, String description,\n                                     List<Integer> tree, boolean expected) {\n    unitTest(options, description, TreeUtils.buildTree(tree), expected);\n  }\n  public static void directedTests(AbstractTestOptions options) {\n    options.startTests(0, \"Check if binary tree is height-balanced\");\n    unitTest(options, \"Trivial test\", null, true);\n    unitTestHelper(options, \"Positive test #1\", Arrays.asList(1), true);\n    unitTestHelper(options, \"Positive test #2\", Arrays.asList(1, 2), true);\n    unitTestHelper(options, \"Positive test #3\", Arrays.asList(2, 1), true);\n    unitTestHelper(options, \"Positive test #4\", Arrays.asList(2, 1, 3), true);\n    unitTestHelper(options, \"Positive test #5\", Arrays.asList(5, 3, 1, 4, 7, 6, 8), true);\n    unitTestHelper(options, \"Positive test #6\", Arrays.asList(5, 3, Integer.MIN_VALUE, 4, Integer.MAX_VALUE), true);\n    unitTestHelper(options, \"Negative test #1\", Arrays.asList(5, 3, 2), false);\n    unitTestHelper(options, \"Negative test #2\", Arrays.asList(5, 3, 4), false);\n    unitTestHelper(options, \"Negative test #3\", Arrays.asList(5, 7, 6), false);\n    unitTestHelper(options, \"Negative test #4\", Arrays.asList(5, 7, 8), false);\n    unitTestHelper(options, \"Negative test #5\", Arrays.asList(5, 4, 3, 2, 7, 6, 8, 9), false);\n    BinaryTreeNode<Integer> a = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> b = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> c = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> d = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> e = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> f = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> g = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> h = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> i = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> j = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> k = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> l = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> m = new BinaryTreeNode<>(1);\n    BinaryTreeNode<Integer> n = new BinaryTreeNode<>(0);\n    BinaryTreeNode<Integer> o = new BinaryTreeNode<>(1);\n    a.left  = b;\n    a.right = k;\n    b.left  = c;\n    b.right = h;\n    c.left  = d;\n    c.right = g;\n    d.left  = e;\n    d.right = f;\n    h.left  = i;\n    h.right = j;\n    k.left  = l;\n    k.right = o;\n    l.left  = m;\n    l.right = n;\n    unitTest(options, \"Example from the book test\", a, true);\n    options.endTests();\n  }\n  public static void main(String[] args) {\n    directedTests(new JsonTestOptions(System.out));\n  }\n}\n", "header": "  public static class BinaryTreeNode<T> {\n    public T data;\n    public BinaryTreeNode<T> left, right;\n\n    public BinaryTreeNode() {}\n\n    public BinaryTreeNode(T data) { this.data = data; }\n\n    public BinaryTreeNode(T data, BinaryTreeNode<T> left,\n                          BinaryTreeNode<T> right) {\n      this.data = data;\n      this.left = left;\n      this.right = right;\n    }\n  }\n", "imports": "import com.epi.utils.AbstractTestOptions;\nimport com.epi.utils.AbstractTestStream;\nimport com.epi.utils.JsonTestOptions;\nimport com.epi.utils.TestType;\nimport com.epi.utils.TreeUtils;\nimport java.util.Arrays;\nimport java.util.List;\n", "package": "package com.epi;\n", "skeleton": "  public static boolean isBalanced(BinaryTreeNode<Integer> tree) {\n    // Your solution here...\n  }\n"}}, "hint": "Think of a classic binary tree algorithm.", "problem": "A binary tree is said to be balanced if for each node in the tree,   the difference in the height of its left and right subtrees is at most one.   A perfect binary tree is balanced, as is a complete binary tree.   A balanced binary tree does not have to be perfect or complete---see the   figure for an example.   <p>   Write a program that takes as input the root of a binary tree   and checks whether the tree is balanced.   <p>   The binary tree class is<pre>   class BinaryTreeNode<T> {       public T data;       public BinaryTreeNode<T> left, right;   }   public BinaryTreeNode(T data) { this.data = data; }   public BinaryTreeNode(T data, BinaryTreeNode<T> left,                          BinaryTreeNode<T> right) {     this.data = data;     this.left = left;     this.right = right;   }</pre><p>   <img src=\"/static/posts/binary-tree.png\"></img>", "slug": "is-binary-tree-balanced", "title": "Test if a binary tree is balanced."}