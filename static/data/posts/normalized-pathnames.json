{"code": {"cpp": {"filename": "normalized_pathnamesTest.cc", "harness": "#include \"test_toolkit/test-options.h\"\n#include <algorithm>\n#include <cassert>\n#include <iostream>\n#include <stdexcept>\n#include <string>\n#include <sstream>\n#include <vector>\n#include \"test_toolkit/main_def.h\"\nusing std::cout;\nusing std::endl;\nusing std::exception;\nusing std::invalid_argument;\nusing std::stringstream;\nusing std::string;\nusing std::vector;\n//INSERT_ME\nvoid UnitTest(TestSentry::Ptr& sentry, const char* description,\n              const string& input, const string& expected) {\n  TestStream::Ptr stream = sentry->GetTestStream(TestType::NORMAL, description);\n  stream->RegisterInput(input);\n  stream->RegisterExpectedOutput(expected.empty() ? \"Invalid path!\" : expected);\n  try {\n    string result = ShortestEquivalentPath(input);\n    stream->RegisterUserOutput(result, !expected.empty() && result == expected);\n  }\n  catch (invalid_argument) {\n    stream->RegisterUserOutput(\"Invalid path!\", expected.empty());\n  }\n  catch (...) {\n    stream->RegisterUnhandledException();\n  }\n}\nvoid DirectedTests(const TestOptions& options) {\n  TestSentry::Ptr sentry = options.GetTestSentry(0, \"Normalized pathnames\");\n  UnitTest(sentry, \"Trivial test #1\", \"/\", \"/\");\n  UnitTest(sentry, \"Normalized path test #1\", \"foo/bar\", \"foo/bar\");\n  UnitTest(sentry, \"Normalized path test #2\", \"/foo/bar\", \"/foo/bar\");\n  UnitTest(sentry, \"Normalized path test #3\", \"./foo/bar\", \"foo/bar\");\n  UnitTest(sentry, \"Double-dot test #1\", \"usr/lib/../bin/gcc\", \"usr/bin/gcc\");\n  UnitTest(sentry, \"Double-dot test #2\", \"usr/bin/../lib/../bin/gcc\", \"usr/bin/gcc\");\n  UnitTest(sentry, \"Double-dot test #3\", \"usr/bin/gcc/include/../../../\", \"usr\");\n  UnitTest(sentry, \"Double-dot test #4\", \"./../\", \"..\");\n  UnitTest(sentry, \"Double-dot test #5\", \"..\", \"..\");\n  UnitTest(sentry, \"Double-dot test #6\", \"../../local\", \"../../local\");\n  UnitTest(sentry, \"Redundant symbols test #1\", \"./.././../local\", \"../../local\");\n  UnitTest(sentry, \"Redundant symbols test #2\", \"/foo/../foo/././../././\", \"/\");\n  UnitTest(sentry, \"Redundant symbols test #3\", \"scripts//./../scripts///awkscripts/././\", \"scripts/awkscripts\");\n  UnitTest(sentry, \"Invalid path test #1\", \"/..\", \"\");\n  UnitTest(sentry, \"Invalid path test #2\", \"/foo/.././../\", \"\");\n  UnitTest(sentry, \"Invalid path test #3\", \"/./.././/\", \"\");\n}\nint main(int argc, char* argv[]) {\n  DirectedTests(TestOptions(&cout));\n  return 0;\n}\n", "skeleton": "string ShortestEquivalentPath(const string& path) {\n    // Your solution here...\n}\n"}, "java": {"filename": "NormalizedPathnamesTest.java", "harness": "public class NormalizedPathnamesTest {\n//INSERT_ME\n  private static void unitTest(AbstractTestOptions options, String description,\n                               String input, String expected) {\n    AbstractTestStream stream = options.getStream();\n    stream.startTest(TestType.NORMAL, description);\n    stream.registerInput(input);\n    stream.registerExpectedOutput(expected.isEmpty() ? \"Invalid path!\" : expected);\n    try {\n      String result = shortestEquivalentPath(input);\n      stream.registerUserOutput(result, !expected.isEmpty() && expected.equals(result));\n    } catch (IllegalArgumentException e) {\n      stream.registerUserOutput(\"Invalid path!\", expected.isEmpty());\n    } catch (NullPointerException e) {\n      stream.registerNullPointerException();\n    } catch (Exception e) {\n      stream.registerUnhandledException();\n    }\n    stream.endTest();\n  }\n  public static void directedTests(AbstractTestOptions options) {\n    options.startTests(0, \"Normalized pathnames\");\n    unitTest(options, \"Trivial test #1\", \"/\", \"/\");\n    unitTest(options, \"Normalized path test #1\", \"foo/bar\", \"foo/bar\");\n    unitTest(options, \"Normalized path test #2\", \"/foo/bar\", \"/foo/bar\");\n    unitTest(options, \"Double-dot test #1\", \"usr/lib/../bin/gcc\", \"usr/bin/gcc\");\n    unitTest(options, \"Double-dot test #2\", \"usr/bin/../lib/../bin/gcc\", \"usr/bin/gcc\");\n    unitTest(options, \"Double-dot test #3\", \"usr/bin/gcc/include/../../../\", \"usr\");\n    unitTest(options, \"Double-dot test #4\", \"./../\", \"..\");\n    unitTest(options, \"Double-dot test #5\", \"..\", \"..\");\n    unitTest(options, \"Double-dot test #6\", \"../../local\", \"../../local\");\n    unitTest(options, \"Redundant symbols test #1\", \"./.././../local\", \"../../local\");\n    unitTest(options, \"Redundant symbols test #2\", \"/foo/../foo/././../././\", \"/\");\n    unitTest(options, \"Redundant symbols test #3\", \"scripts//./../scripts///awkscripts/././\", \"scripts/awkscripts\");\n    unitTest(options, \"Invalid path test #1\", \"/..\", \"\");\n    unitTest(options, \"Invalid path test #2\", \"/foo/.././../\", \"\");\n    unitTest(options, \"Invalid path test #3\", \"/./.././/\", \"\");\n    options.endTests();\n  }\n  public static void main(String[] args) {\n    directedTests(new JsonTestOptions(System.out));\n  }\n}\n", "imports": "import com.epi.utils.AbstractTestOptions;\nimport com.epi.utils.AbstractTestStream;\nimport com.epi.utils.JsonTestOptions;\nimport com.epi.utils.TestType;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.LinkedList;\n", "package": "package com.epi;\n", "skeleton": "  public static String shortestEquivalentPath(String path) {\n    // Your solution here...\n  }\n"}}, "hint": "Trace the cases. How should . and .. be handled? Watch for invalid paths.", "problem": "A file or directory can be specified via a string called the pathname. This string may specify an absolute path, starting from the root, e.g., <pre>/usr/bin/gcc</pre>or a path relative to the current working directory, e.g., <pre>scripts/awkscripts</pre> <p> Write a program which takes a pathname, and returns the shortest equivalent pathname. The function throws an <b>IllegalArgumentException</b> if the taken path is invalid. Assume individual directories and files have names that use only alphanumeric characters. Subdirectory names may be combined using forward slashes (/), the current directory (.) and parent directory (..). ", "slug": "normalized-pathnames", "title": "Normalize pathnames"}